# Redux

## 为什么需要有redux

### 变量的冲突
上一节讲到一个问题，就是全局变量。  
假设我们的数据交互非常的快，就会出现这个在数据库课堂经典的问题。  
假设变量x是全局变量，a函数为

```js
function a(){
    let a=x
    //do someting here to change a
    //
    x=a
}
```

假设这个函数耗时0.3s，这个时候又有另一个行为再次触发a函数。  
此时第一个函数的返回尚未更改a，另一个函数又将a赋与x，这个时候将会导致第一次触发函数a的事件失效。  
这简直是不能忍的。
这个时候咋办？数据库跟你讲了个方法，就是“原子性”  
简单说来是执行完了一个再来一个，所以就要有一个东西去hold住全场，维持变更执行的顺序。

### React的设计缺陷
另一个问题就是React的事件机制的问题。
React 会触发渲染周期的事件无非就是几个
1. props发生变化
2. state发生变化
但是发现没有？我们的状态变更里面并没有全局变量的改变。  
也就很是说，如果你的全局变量发生了变化，但是实际上并没有卵用。因为组件并不会刷新自己。
那这个时候怎么办？
很简单啊！把全局变量托管至最高的父节点，然后呢，当做props传下来呗。
这样prop改变了，组件自然就会更新了。
不过性能堪忧，代码也不够优雅。
爷爷级别的父组件改变，导致所有的组件都要做一次diff，当页面比较庞大的时候就会感觉到性能的下降了。
另一个问题就是，所有组件都要把prop传给子节点，写得也未免太累了。

所以呢React暴露了一个叫做Context Api，context的中文翻译是上下文。  
具体的api语法我们到时候再讲，现在只是简单模糊的说明一下原理。
就是React给你一个后门，你把全局变量丢到context里面。  
然后你需要用到这个上下文的组件的地方，你呢，就用context暴露的方法包着你的子组件，这样context一变，子组件就跟着变。  
而用不到全局变量的地方，就当做这个全局变量不存在，不会触发diff。这就解决了props传递性能低下且不优雅的问题。

## Redux的演变历程
由于上述的原因，Facebook首先封装了Flux，不过Flux比较重型，于是又有人创作了Redux。
Redux取得了巨大的成功，几乎是要用到React的就要用到Redux。不过，Redux的写法很多，很繁杂，所以又创作出了Mbox或者是在Redux上面继续封装的Rematch。





